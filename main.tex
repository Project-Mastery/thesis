\documentclass[twoside, 11pt]{article}

\usepackage{meta/ipcb}

\begin{document}

\input{title.tex} 
\blankpage
\newpage

\section*{Composição do Juri}

\noindent Presidente do júri

Grau académico, nome do presidente do júri

\noindent Vogais

Grau académico, nome do presidente do júri

Categoria profissional e o nome da Instituição

\vspace{1cm}

Grau académico, nome do presidente do júri

Categoria profissional e o nome da Instituição

\vspace{1cm}

Grau académico, nome do presidente do júri

Categoria profissional e o nome da Instituição

\clearpage            % Ensure all floats and content are flushed
\null                % Create an empty box (no content)
\newpage             % Move to the next page

\section*{Resumo}

Este resumo não deverá ter uma extensão superior a 500 palavras em  português, inglês ou espanhol.

\section*{Palavras chave}

Cinco palavras chave no máximo.

\clearpage            % Ensure all floats and content are flushed
\null                % Create an empty box (no content)
\newpage             % Move to the next page

\section*{Abstract}

Este resumo não deverá ter uma extensão superior a 500 palavras, por regra apresenta-se em inglês. Nos casos em que o documento seja escrito em língua inglesa ou espanhola, o abstract apresenta-se em  português.

\section*{Keywords}

Cinco palavras chave no máximo.

\clearpage            % Ensure all floats and content are flushed
\null                % Create an empty box (no content)
\newpage             % Move to the next page

\printglossary[type=\acronymtype,nonumberlist, title=List of Abbreviations]

\clearpage            % Ensure all floats and content are flushed
\null                % Create an empty box (no content)
\newpage             % Move to the next page

\renewcommand{\contentsname}{General Index}
\tableofcontents

\clearpage            % Ensure all floats and content are flushed
\null                % Create an empty box (no content)
\newpage             % Move to the next page

\renewcommand{\listfigurename}{Figure Index}
\listoffigures

\clearpage            % Ensure all floats and content are flushed
\null                % Create an empty box (no content)
\newpage             % Move to the next page

\renewcommand{\listtablename}{Table Index}
\listoftables

\clearpage            % Ensure all floats and content are flushed
\null                % Create an empty box (no content)
\newpage             % Move to the next page

\mainmatter

\section{Introduction}

Pedestrian dynamics is an area of study focused on understanding the movement of pedestrians, which often happens as crowds. Such studies can take the form of an analysis of data collected from studying the movements of people in the real world \cite{adrianCrowdsFrontBottlenecks2020}, proposition and evaluation of methods for modeling crowd behavior \cite{vonkruchtenEmpiricalStudySocial2017}, predicting movement patterns in certain spaces \cite{10181234}, among others. They may also take into account other factors, such as vehicles \cite{liangUnravelingCausesSeoul2024} and changes to the environment \cite{helbingSimulatingDynamicFeatures2000}. As such, pedestrian dynamics are of practical use when creating spaces meant to be utilized by people. A better understanding of how people move through a structure may aid during the design phase of a building, allowing for better planning of fire escape routes \cite{kouskoulisSystematicReviewPedestrian2017}. Similarly, not taking into account how people will behave may turn concerts or other large events into deadly crowd crushes and increase the number of trampling incidents \cite{barrStampedesNewPsychology2024}. Finally, even when there is little risk of loss of life, they may still be useful for increasing the throughput of infrastructure such as train stations, airports, and others \cite{tesoriereModellingSimulationPassenger2018}.

One of the best tools from this area of study comes in the form of simulation models. Computer simulations allow us to check how pedestrians will behave in a certain environment without having to spend time and resources on the construction and evaluations of scale models in the real world. This reduces costs and promotes fast iterative designs that may better align with the requirements of spaces. It also bypasses ethical considerations that arise when attempting to replicate crowd crushes and other deadly situations for research. Study about these can happen via the records of past events, but these are limited as these rarely happen under circumstances where data can be effectively collected. For these scenarios, simulations are some of the only ways to gather more profound insight.

There are many  models that have been made for simulating the flow of pedestrians in an environment. However, designing and implementing models capable of reproducing phenomena seen in the real world is complicated. Pedestrian dynamics is an inherently interdisciplinary science \cite{kleinmeierVadereOpenSourceSimulation2019} due to its object of study. It relies on concepts from areas as diverse as physics, engineering, psychology, computer science, and sociology. Simpler models may take into account only the physical part of crowd movement and ignore all else, while others deal with the effects of having people with different ages \cite{gorriniAgeGroupdrivenPedestrian2016}, disabilities \cite{fuExperimentalStudyBidirectional2022} or even states of mind such as calm and panic \cite{Alrashed_Shamma_2020}.

When these models are implemented, it is often done on top of an existing simulator or framework. These allow model authors to focus on the most relevant parts of their research while other tasks are handled by code already written and validated by others. Nevertheless, building a model on top of these simulators also comes with certain disadvantages. Their architecture imposes restrictions on how the model can operate, meaning that certain simulators may not be compatible with a model because it breaks one or more of the assumptions made when the simulator was being designed. Similarly, the architecture and technologies used by the simulator have an effect on the performance of the simulation. While less impactful than full incompatibility between model and simulator, low performance can slow model development and usage. Larger or more complicated scenarios may take longer than desired to be evaluated or require additional hardware.

While there are many ways of mitigating such problems, using architectures found in other areas, such as \gls{ecs}, offer some benefits. \gls{ecs} is a software architecture sometimes used in game development due to its much stricter flexibility and performance requirements than standard simulators. Developers expect such frameworks to be able to grow as the needs of the project expand and to handle thousands of entities updating multiple times a second. Not only that, but, as this work will show, these benefits can be used in many scenarios, including the study of crowds. Despite this, \gls{ecs} is still very uncommon in the scientific world.

With this in mind, this work proposes a new simulation framework for pedestrian dynamics: \gls{ecsmos}. This simulator is based on the \gls{ecs} architecture and has a focus on being as flexible as possible for model authors while maintaining a high performance. Its main objective is to determine the viability, benefits, and drawbacks of such an architecture in the field of pedestrian simulations. This is done by implementing the core of a novel simulation framework and comparing it to existing simulators in various scenarios.


The rest of this work is structured as follows: \autoref{sec:overview} provides an overview of existing pedestrian simulation models, how they operate, and what simulation frameworks are available. \autoref{sec:ecs-architecture} talks about the details of the \gls{ecs} architecture, its benefits, and its drawbacks. \autoref{sec:ecsmos-implementation} goes over the details of how \gls{ecsmos} was implemented. \autoref{sec:evaluation} defines the evaluation criteria used to validate \gls{ecsmos} and compares it to other simulators. Finally, \autoref{sec:conclusion} provides the final remarks of the work done and concludes this dissertation.

\section{Current state of pedestrian modeling and simulation} \label{sec:overview}

\subsection{Pedestrian models}

Modeling pedestrians is a complicated affair. Humans have both conscious, subconscious and even physical aspects that affect how one moves. Because of this, there are many competing models in use, each one with its own benefits and limitations. There are many ways of categorizing them generally. One of the most common is based on the scale of the entities involved \cite{kleinmeierVadereOpenSourceSimulation2019}. Microscopic models focus on individual pedestrians and their movement, while macroscopic models avoid dealing with interactions between discrete entities, preferring to model the behaviors of whole crowds directly.

Another way of categorizing models is proposed by \cite{martinez-gilModelingEvaluationScale2017}, which divides models into the following groups:

\begin{itemize}
  \item Mechanics-based models: Inspired by continuum mechanics or force models.
  \item Cellular automata models: These interpret the world as discretized units on a grid. Agents operate under defined rules that determine how they move on the grid.
  \item Stochastic models: Use random or probabilistic models to determine behavior.
  \item Agency models: Pedestrians are treated as agents that can sense and reason about the world. They make choices about where to move depending on their perceptions of the outside world.
  \item Data-driven models: Based on data collected from experiments and other sources. Uses that for building and calibrating a model.
\end{itemize}

However, both kinds of divisions are descriptive, not prescriptive. Models routinely fit into multiple or in between. Where they fall is mostly determined by the requirements and constraints of the model authors. Exotic requirements may lead to models being completely out of these constraints.

This dissertation will focus mostly on the \gls{sfm}, a microscopic mechanics-based model originally proposed in 1995 \cite{helbingSocialForceModel1995}. That is because many implementations of it have been proposed and added in various simulators over the years. Providing an even ground for comparisons between simulators. Its behavior is known and well understood. In particular, the version described in \cite{helbingSimulatingDynamicFeatures2000} will be used, as it is more similar to the implementations present in today's simulators.

The \gls{sfm} describes interactions between pedestrians and the environment as forces. Pedestrians are modeled as circles, and, at each point in time, certain forces are applied upon them and are used to compute their acceleration, velocity, and ultimately position. Through careful calibration, these forces can reasonably model the behaviors of people moving. The original model defined three main kinds of forces. However, some implementations may add more forces, taking into consideration other aspects.

The first kind of force to take into account is the driving or motivation force, computed by \autoref{eq:driving_force}. This is a force that attempts to move the pedestrian in the direction of its ultimate destination. If a lone agent were placed in an empty plane and given a target destination, the motivation force would be a constant vector pointing to its destination. If there are obstacles on the way, the direction of the force might change to steer the pedestrian into the shortest available path. Which is the shortest path needs to be computed by some other means, as the model itself does not specify how.

\begin{equation}
  \vec{F_i^{drv}} = \frac{v_i^0 \vec{e_i^0} - \vec{v_i}}{\tau}
  \label{eq:driving_force}
\end{equation}
where:
\begin{description}
  \item[$\vec{F_i^{drv}}$] is the driving force on pedestrian $i$
  \item[$v_i^0$] is the desired speed: the speed at which the pedestrian $i$ would prefer to walk
  \item[$e_i^0$] is a unit vector pointing to the desired direction
  \item[$\vec{v_i}$] is the current speed of pedestrian $i$
  \item[\tau] is the reaction time: the time it takes pedestrians to notice changes in their surroundings 
\end{description}

The environment around an agent may also impose repulsive forces upon them. Pedestrians naturally attempt to keep some distance between themselves and others both for comfort and to guarantee the ability to continue moving forward. This is modeled as a repulsive force between them. The force between pedestrians $i$ and $j$ is symmetrical between them, and the final force (see \autoref{eq:pedestrian_repulsion_total}) on $i$ is the sum of all repulsive forces applied by other pedestrians (see \autoref{eq:pedestrian_repulsion}).

\begin{equation}
  \vec{F_i^{rep}} = \sum_i\vec{f_{ij}}
  \label{eq:pedestrian_repulsion_total}
\end{equation}

\begin{equation}
  \vec{f_{ij}} = [A_ie^{\frac{r_{ij} - d_{ij}}{B_i}} + kg(r_{ij}-d_{ij})]\vec{n_{ij}} + \kappa g (r_{ij} - d_{ij})\Delta v_{ji}^t \vec{t_{ij}}
  \label{eq:pedestrian_repulsion}
\end{equation}
where:
\begin{description}
  \item[$\vec{F_i^{rep}}$] is the total repulsive force from other agents on $i$
  \item[$\vec{f_{ij}}$] is repulsive force from $j$ on $i$
  
  \item[$r_{ij}$] $= r_i + r_j$ is the sum of the radius of $i$ and $j$
  \item[$d_{ij}$] is the distance between the center of $i$ and the center of $j$
  \item[$g$] is the contact distance between the pedestrians. If they are not touching, it is $0$; otherwise, it is the distance between the center of $i$ and the center of $j$
  \item[$\vec{n_{ij}}$] is a unit vector pointing from $j$ to $i$
  \item[$\vec{t_{ij}}$] is a unit vector perpendicular to $\vec{n_{ij}}$, rotated counterclockwise
  \item[$\Delta v_{ji}^t$] $= (\vec{v_j} - \vec{v_i}) \cdot t_{ij}$ is the tangential velocity difference of $i$ and $j$
  \item[$A$, $B$, $k$, \kappa] are calibration constants
\end{description}

In practical terms, the repulsive force has two main components: a normal and a perpendicular vector. The normal forces two pedestrians away from each other, increasing depending on how close they are. If the pedestrians are close enough to touch, that force additionally increases by a secondary factor that is dependent on how much they intersect. In this way, the normal component captures both the psychological desire for space and the physical constraints preventing pedestrians from packing too tightly. The perpendicular vector represents sliding forces. When two pedestrians touch, there is some friction between them that acts to slow them down. Friction acts perpendicularly to the normal and against the direction of movement. These forces can be seen in \autoref{fig:repulsive-forces}.

\begin{figure}[h]
  \centering
  \includesvg{repulsive_forces.drawio.svg}
  \caption{Diagram of repulsive forces between pedestrians $i$ and $j$}
  \label{fig:repulsive-forces}
\end{figure}

The final class of force to consider is the obstacle force. Much like the previous repulsive forces, agents also attempt to keep a certain distance from them to walls and other obstacles in their surroundings. If they touch those objects, there is also an additional factor that increases the normal repulsion and a factor describing friction. However, most obstacles are not perfect circles, so the function uses the closest point of the obstacle for distance measurements.

\begin{equation}
  \vec{F_i^{obst}} = \sum_o\vec{f_{io}}
  \label{eq:pedestrian_obstacle_total}
\end{equation}

\begin{equation}
  \vec{f_{io}} = [A_ie^{\frac{r_i - d_{io}}{B_i}} + kg(r_i-d_{io})]\vec{n_{io}} + \kappa g (r_i - d_{io})(\vec{v_i} \cdot \vec{t_{io}})\vec{t_{io}}
  \label{eq:pedestrian_obstacle}
\end{equation}
where:
\begin{description}
  \item[$\vec{F_i^{obst}}$] is the total force from obstacles on agent $i$
  \item[$\vec{f_{io}}$] is the force from obstacle $o$ on $i$
  \item[$r_i$] is the radius of $i$
  \item[$d_{io}$] is the minimum distance from the center of $i$ to any point of $o$
  \item[$g$] is the contact distance between the pedestrian and the obstacle. If they are not touching, it is $0$; otherwise, it is equal to $d_{io}$
  \item[$\vec{n_{io}}$] is a unit vector pointing from the center of $i$ to the closest point of $o$
  \item[$\vec{t_{io}}$] is a unit vector perpendicular to $\vec{n_{io}}$ rotated counterclockwise
  \item[$A$, $B$, $k$, \kappa] are calibration constants
\end{description}

\begin{figure}[h]
  \centering
  \includesvg{obstacle_forces.drawio.svg}
  \caption{Diagram of obstacle forces between pedestrian $i$ and obstacle $o$}
  \label{fig:obstacle-forces}
\end{figure}

In each simulation step, all of these forces are computed for each agent, then they are used to compute its new speed and position. Using basic Newtonian physics, equations \eqref{eq:pedestrian_final_speed} and \eqref{eq:pedestrian_final_position} can be derived. Once the agents are moved to their new locations, the simulation forces are calculated once again. This process repeats until the desired results are achieved.

\begin{equation}
  \vec{v_i^{new}} = \vec{v_i} + ( F_i^{drv} + \frac{\vec{F_i^{rep}} + \vec{F_i^{obst}}}{m_i} ) \cdot \Delta T
  \label{eq:pedestrian_final_speed}
\end{equation}

\begin{equation}
  \vec{pos_i^{new}} = \vec{pos_i} + \vec{v_i^{new}} \cdot \Delta T
  \label{eq:pedestrian_final_position}
\end{equation}
where:
\begin{description}
  \item[$\vec{v_i^{new}}$] is the new speed of the agent $i$
  \item[$\vec{v_i}$] is the previous speed of $i$
  \item[$\vec{F_i^{drv}}$] is the driving force on pedestrian $i$
  \item[$\vec{F_i^{rep}}$] is the total repulsive force from other agents on $i$
  \item[$\vec{F_i^{obst}}$] is the total force from obstacles on agent $i$
  \item[$m_i$] is the mass of $i$ 
  \item[$\Delta T$] is the length of the simulation step
  \item[$\vec{pos_i^{new}}$] is the new position of $i$
  \item[$\vec{pos_i}$] is the previous position of $i$
\end{description}

Despite its relative simplicity, this model is quite robust and is capable of replicating certain phenomena that are seen in empirical studies. For example, it replicates the "Faster-Is-Slower Effect", which occurs when the flow rate of pedestrians through an obstruction paradoxically decreases once a certain speed is surpassed \cite{helbingSimulatingDynamicFeatures2000}. The \gls{sfm} also reproduces lane formation, which is when pedestrians form lanes of people going in the same direction when two streams of people converge in a limited space \cite{PhysRevE.94.032304}. An example of what lane formation looks like can on \autoref{fig:lane-formation}.

\begin{figure}[!h]
  \centering
  \includesvg{lane_formation.drawio.svg}
  \caption[Example of lane formation]{Example of lane formation. Each circle represents a pedestrian, the arrows represent their direction of motion. When multiple streams of pedestrians that go in different directions converge in a confined space, pedestrians going to the same destination tend to follow one another, causing the formation of lanes that go in different directions.}
  \label{fig:lane-formation}
\end{figure}

\subsection{Existing simulation frameworks} \label{sec:existing-frameworks}

Before a full establishment of the design requirements for \gls{ecsmos} was made, it was necessary to study currently available solutions.While there are many commercial products for simulating the behavior of pedestrians, they are all closed source and proprietary for the most part, meaning that it is difficult to scrutinize their results or implement new models. Solutions like this include PTV Viswalk \cite{viswalk}, MassMotion \cite{massmotion}, Legion Simulator \cite{legionsimulator} and AnyLogic \cite{anylogic}. Due to these limitations, scientific research tends to focus on more open simulators. 

To determine which simulators were most used and relevant to this work, a survey was performed. The following scientific article databases were searched: Google Scholar, IEEE Xplore, arXiv, SpringerLink, Science Direct and the Association for Computing Machinery Digital Library. For the search, the terms "pedestrian simulation", "pedestrian model", "pedestrian traffic", "pedestrian dynamics", "crow simulation", "crowd dynamics", "pedestrian motion", "crowd motion", "pedestrian movement", and "crowd movement" were used.
The results were then filtered by date, removing anything prior to 2010. Finally, the top 50 results from each were evaluated.

After the initial search and evaluation, it was also specifically decided to add the articles from the journal Collective Dynamics to the search. This was done because, of the simulators found during the initial search, many of them were originally published there, and the journal received a higher than average rate of citation on the other works. Despite this, its articles were not properly indexed by the major databases, possibly because of its small size, relative youth as a journal, and narrow focus on pedestrian and vehicular simulations. 

Of the selected articles, most used custom-made software for the specific use case the researchers had in mind or did not reference a specific framework. While some of those in the former case made their code available, it was decided to not take these into account. This was done because such implementations are usually not meant to be extended by other developers. Therefore, this dissertation will only focus on simulation frameworks with the purpose of being used by other people than the authors themselves. Among these, only open-source ones with at least one update since 2015 were considered. 

\subsubsection{Description of available simulation frameworks}

These were the simulation frameworks that passed all the filtering criteria:

\textbf{Cromosim} is a Python library for crowd simulations \cite{cromosim}. While it benefits from Python's large ecosystem of scientific tools, Cromosim has little pre-built infrastructure when it comes to helping researchers. Even basic models such as the social forces model are not already included.

\textbf{FDS+Evac} is a module for \gls{fds} developed by the Technical Research Center of Finland for the purposes of simulating pedestrian movement in building fire scenarios \cite{korhonenFireDynamicsSimulator2009}. It is agent-based, uses the social forces model, and is mostly suited for evacuation scenarios in buildings with relatively flat floor plans. Buildings with a large degree of vertical movement within a single floor (stadiums, concert halls, and cinemas, for example) may present some challenges. However, this module has been discontinued as of version 6.7.8 of \gls{fds}.

\textbf{jCrowdSimulator} is a pedestrian simulator written in Java and maintained by the Fraunhofer Institute for Transport and Infrastructure Systems \cite{meinert2019simulation}. It can be used in the form of a library or as a stand-alone application. Currently, it only implements the social forces model, and its implementation is tightly coupled to the rest of the simulator, meaning that adding new models can be a challenge.

\textbf{JuPedSim} is a Python package with a C++ core for simulating pedestrian dynamics. Despite not having a \gls{ui} \cite{kemlohwagoumJuPedSimOpenFramework2015}, JuPedSim is simple to use. It also includes various modules for flow/density analysis, image generation, 2D or 3D animations, reporting, and geometry generation. Model implementation is divided into three levels. (1) Tactical: route choice and short-term decisions. (2) Strategic: Long-term decisions and general objectives. (3) Operational: How to perform each action. JuPedSim can be executed inside Jupyter Notebooks for a more interactive experience. While extremely flexible for users, the fact that its codebase is split between languages and that its internal structure is tightly bound to the implemented models poses problems for developers.

\textbf{Menge} is a modular framework for simulating crowd movement that decomposes the problem of how to simulate human movement into four main tasks \cite{curtisMengeModularFramework2016}. (1) Goal selection: Deciding what each pedestrian wants to achieve. (2) Plan computation: deciding on a strategy to achieve a pedestrian's objective. (3) Plan adaptation: Adapt the original plan to the current local environment of the pedestrian. (4) Spatial queries: How to retrieve data around a certain point and decide what kinds of data are useful. \autoref{fig:menge_architecture} provides some additional detail on how these parts interact. To add a new model to the simulator, it is necessary to break it down into these four components while also obeying the other interface restrictions. If the new model is similar enough to another in one of these areas, it is possible to reuse that part of the implementation. However, implementing models that do not fit well into these divisions can be challenging. Menge includes a \gls{ui} and various examples of its basic features. However, its last stable version was released in 2017, and all development stopped in 2019.

\begin{figure}[h]
  \centering
  \includesvg[inkscapelatex=false]{menge_architecture.drawio.svg}
  \caption[Menge architecture and simulation flow]{Menge architecture and simulation flow. Adapted from \cite{curtisMengeModularFramework2016}.}
  \label{fig:menge_architecture}
\end{figure}


\textbf{Vadere} is a simulation framework for comparing different locomotion models developed by the Munich University of Applied Sciences \cite{kleinmeierVadereOpenSourceSimulation2019}. It was designed to be lightweight while still remaining relatively flexible. It contains both a simulation engine that can be executed via command line or via its own \gls{ui}. As shown in \autoref{fig:vadere_architecture}, Vadere follows the \gls{mvc} architecture where the \gls{ui} serves as the view, the state is the model, and the simulator core is the controller. Inside the simulation core, models are not implemented following any specific division of responsibilities like those seen in other simulators. Instead, it uses a more integrated approach. However, Vadere was designed to use a mechanism called floor fields to compute the paths of pedestrians. While this implementation has its benefits \cite{seitzSuperpositionPrincipleConceptual2016}, it imposes a performance drop on cellular automata models \cite{kleinmeierVadereOpenSourceSimulation2019}. Attempting to use other approaches would require rewriting large portions of its internal workings.

\begin{figure}[h]
  \centering
  \includesvg[inkscapelatex=false]{vadere_architecture.drawio.svg}
  \caption[Vadere architecture]{Vadere architecture. Adapted from \cite{seitzSuperpositionPrincipleConceptual2016}}
  \label{fig:vadere_architecture}
\end{figure}

\textbf{MomenTUMv2} is a microscopic agent-based pedestrian simulator written in Java and developed by the Technical University of Munich \cite{kielarMomenTUMv2ModularExtensible2016}. Most of its inner workings are implemented in the form of models, which are thought of as "operation providers". These are implementations of the Strategy and Template Method software patterns. This modularity is very broad, including configuration, pedestrian generators/removers, analyzers, and much more. Models that do not fit into any predefined category can be added in a special section. When compared to other solutions such as Vadere, it is much more adaptable, but it comes with a cost in terms of complexity and implementation time. One of its main benefits is that it allows the use of hybrid models, meaning models that connect two or more pre-existing models of the same layer to create behavior that is a mixture of them depending on the circumstances. Finally, it has seen very little change since 2018, and its last update was in 2020. Since then, there has been no development activity, and its lead developer no longer works at the Technical University of Munich. The most recent available versions of the code are not able to be executed due to the incomplete implementation of certain features. A simplified version of MomenTUMv2's architecture and execution flow can be seen in \autoref{fig:momentun_architecture}.

\begin{figure}[h]
  \centering
  \includesvg[inkscapelatex=false,width=\textwidth]{momentun_architecture.drawio.svg}
  \caption[Simplified MomenTUMv2 structure and flow]{Simplified MomenTUMv2 structure and flow. Adapted from \cite{kielarMomenTUMv2ModularExtensible2016}. Dashed rectangles represent organizational units. Solid rectangles represent a set of generic models or sets, which may contain many other families of sub-models within.}
  \label{fig:momentun_architecture}
\end{figure}

\textbf{\gls{sumo}} is a traffic simulator widely used in traffic engineering and related topics \cite{SUMO2018}. While it is mostly focused on vehicular movement, it does have some built-in mechanisms to simulate pedestrian movement. However, these were built with the purpose of enriching the traffic simulations and are very limited. For example, pedestrians are not allowed to freely roam in the 2D plane; they are restricted to certain lines/paths. For more robust simulation capabilities, it is possible to use JuPedSim together with \gls{sumo}. However, this integration is still a work in progress.

Finally, there are other libraries such as \textbf{Mesa} \cite{hoevenMesa3Agentbased2025}, \textbf{Agents.jl} \cite{Agents.jl}, and many others, which focus on agent-based modeling. While these can be used for pedestrian simulations, they have little to no pre-built infrastructure for model authors, requiring a full implementation to be done for any comparison. However, due to their larger audience, they may have better tools for analysis and documentation that other purpose-built simulators. \autoref{table:available-simulators-summary} contains a summary of the considered frameworks and their characteristics. It is worth noting that projects with no clear status and no recent activity were classified as inactive. Only projects that have been officially terminated were classified as discontinued.

\begin{center}
  \begin{table}[h]
    \begin{tabularx}{\textwidth}{ | X | c | c | c | c | c | } 
      \hline
      Name & Languages & Has \gls{ui} & License & Last Update & Project Status \\ 
      \hline
      Cromosim & Python & No & GPL-3.0 & 2024 & Supported\\
      \hline
      FDS+Evac & Fortran & Yes & Custom & 2022 & Discontinued \\
      \hline
      jCrowdSimulator & Java & No & LGPL-3.0 & 2024 & Supported \\
      \hline
      JuPedSim & C++ and Python & No & LGPL-3.0 & 2025 & Supported \\
      \hline
      Menge & C++ & Yes & Apache-2.0 & 2019 & Inactive \\
      \hline 
      MomenTUMv2 & Java & Yes & Custom & 2020 & Inactive \\
      \hline 
      \gls{sumo} & C++ and Python & Yes & EPL-2.0 & 2025 & Supported \\
      \hline 
      Vadere & Java & Yes & LGPL-3.0 & 2025 & Supported \\
      \hline 

    \end{tabularx}
    \caption{Summary of available simulators}
    \label{table:available-simulators-summary}
  \end{table}
\end{center}

\subsubsection{Evaluation of available simulation frameworks}

Despite the variety of available tools, most of these are only compatible with a subset of models. Menge has a well-defined structure that facilitates development, but it only works well when a model can be split into its four types of tasks. Vadere and JuPedSim are very popular in general. However, their internal architecture is too monolithic, preventing code from being effectively shared between pre-existing models and new implementations. MomenTUMv2 is possibly the most modular. However, this is achieved via a lot of complexity within its architecture. Finally, libraries like Agents.jl are very capable of adapting themselves to many different kinds of models but lack any infrastructure for pedestrian  simulations specifically.

As a result of these limitations, many researchers in the field end up creating their own purpose built simulations. This makes comparison much harder, as certain implementation specificities can have impacts that are difficult to predict and take into account in a comparison. Removing these limitations could greatly improve comparability and convenience for model authors.

\section{The \acrlong{ecs} architecture} \label{sec:ecs-architecture}

The \gls{ecs} architecture is a data-oriented design pattern or framework sometimes used in the game development industry due to its flexibility, modularity, and high performance. However, it is difficult to find concrete statistics when it comes to its use, as most games are closed source and their inner workings are not widely discussed. It also has a loose definition and is sometimes confused with other similar software architectures that are also common in the area, most notably \gls{ec}. Additionally, the various implementations can be substantially different due to their underlying technologies and objectives. Finally, there are few academic sources for this topic. Most works on this subject are blogs, videos, and personal anecdotes. Because of these factors, this section will discuss the most common aspects of the \gls{ec} architecture, saving details of the specific implementation used for \gls{ecsmos} discussed in \autoref{sec:ecsmos-implementation}. Nevertheless, this architecture has the potential of addressing many of the problems raised in \autoref{sec:existing-frameworks}, and merits further exploration.

\subsection{General structure}

Generally speaking, in an \gls{ecs} implementation, most things are divided into the following three main kinds of concepts: 

\textbf{Entities} represent general objects in the world. For example, in a crowd simulation, each pedestrian would be an entity, but so would obstacles and other things that might affect them. Usually, they consist of a simple identifier that can be used to group other kinds of data. Entities usually do not carry additional data, but many implementations allow entities to be "disabled", meaning that they are not used/visible to other parts of the architecture.


\textbf{Components} can be considered the attributes of entities. Each component is associated with only one entity and stores the data relevant for a certain aspect of its behavior. In most implementations, each entity may also only have one component of each type associated with it. Following the previous example, each pedestrian would have a position component and a speed component, each of which contains all the data necessary to characterize the entity on the relevant aspect. Entities may have as many components as necessary to describe their behavior. However, components do not contain logic. On the other hand, some components also do not store data within them; their presence is already the data itself. In this situation, the component works like a tag, marking the entity as possessing a certain property. For example, an entity that is a pedestrian may have an empty \verb|Pedestrian| component, which serves only as a tag for filtering.

\textbf{Systems} are processes that can read and modify components. They are the main place for logic in this architecture. They usually have a well-defined singular purpose and can access all data as though it were global. For example, a simple system might move entities to their next position according to their speed component. Systems are executed in a predefined order that may be specifically determined by the developer or derived by some set of rules. One common implementation of rules-based ordering is to define the dependencies of each system, meaning systems that must be executed before each one starts. This allows the framework to define by itself when each system is executed. Once all systems have been executed, the cycle is started once more from the first system, creating a loop. Systems are also usually capable of filtering the entities that they want to read data from or operate on by using the presence or absence of certain components.

\begin{figure}[h]
  \centering
  \includesvg[inkscapelatex=false]{ecs_basic_example.drawio.svg}
  \caption[Example of how an ECS project is divided]{Example of how an ECS project is divided. On the right, there are entities and their related components. On the left, systems are shown. Systems are executed according to their specified order, and read/write data to and from the components.}
  \label{fig:ecs_basic_example}
\end{figure}

\autoref{fig:ecs_basic_example} contains an example of how these three concepts interact.  Another way of understanding these concepts is to compare them to a relational database. In this paradigm, each component type has its own table and uses the entity it is associated with as a primary key. A system then would perform queries for the data in the database. The entity information can be used for joining data from different component tables, and the presence or absence of each component can be used to filter out certain entities. In this way, systems can perform operations only on entities that are relevant to the systems function. A system may also write back to the database, and following systems can access the newly written data. This general structure can be seen in \autoref{fig:ecs_db_example}.

\begin{figure}
  \centering
  \includesvg[inkscapelatex=false,width=\textwidth]{ecs_as_database.drawio.svg}
  \caption[Example of how an ECS can be seen as a database]{Example of how an ECS can be seen as a database. Adapted from \cite{csherratt}.}
  \label{fig:ecs_db_example}
\end{figure}

\subsection{Component storage strategies}

While all \gls{ecs} implementations have the same basic structure, one of the main differentiating factors between them is the underlying method for storing the component data and their connections to an entity. Since querying entity and component data is one of the most performed operations on this paradigm, having a well-thought-out method for storing and retrieving such data is of utmost importance. The following is a non-exhaustive categorization of ECS implementations when it comes to this aspect:

\textbf{Archetypes}: Implementations that rely on archetypes group entities based on the components they have. Each combination is called an archetype and is stored in a contiguous area of memory, often as a struct of arrays, meaning that they have great cache spatial locality. When a system requires data, the framework checks which archetypes conform to the requirements and provides the data. This strategy has the best iteration performance of the discussed implementations. However, adding or removing components from an entity forces it to move all the data related to that entity to another archetype. This reduces the efficiency of such operations. Examples that mainly use this approach include Flecs \cite{flecs}, Unity DOTS \cite{unityDots}, Bevy ECS \cite{bevy}, Legion \cite{legion} and Hecs \cite{hecs}. For a visual example, see \autoref{fig:ecs_archetype_example}.

\begin{figure}
  \centering
  \includesvg[inkscapelatex=false,width=\textwidth]{archetype_based_ecs.drawio.svg}
  \caption[Example of how archetype-based ECS stores components]{Example of how archetype-based ECS stores components.}
  \label{fig:ecs_archetype_example}
\end{figure}

\textbf{Sparse set}: In sparse set implementations, a sparse set is maintained for each component type. Sets use entities as keys to retrieve components, and the framework checks all the sparse sets for the components each system requests to gather the data. As a result, iteration over the entities is much slower due to lack of cache locality. However, adding or removing components becomes much faster. Entt \cite{entt} and Shipyard \cite{shipyard} are some of the most well-known frameworks that use sparse sets. This approach is the most similar to the one depicted in \autoref{fig:ecs_db_example}.

\textbf{Bitset-based}: As the name suggests, bitset-based implementations work by using a bitset to say if an entity has a certain component. This can be done by having arrays that contain the component data and a bitset for each entity, or it can use other data structures such as hierarchical bitsets, which may provide better iterative performance. EntityX \cite{entityx} and Specs \cite{specs} are some notable examples in this area.

Due to the many benefits and drawbacks of each approach. Some \gls{ecs} frameworks allow for the storage type to be defined on a component-by-component basis. Such an approach allows developers to maximize the performance of the system. Generally speaking, most components should be stored in something similar to what the archetype implementation uses, which gives the best possible iterative performance. However, components that are frequently added and removed in short succession can be stored similarly to sparse set or bitset implementations to reduce the overhead of these operations. Examples of frameworks that allow for such a nuanced approach include Bevy ECS \cite{bevy} and Specs \cite{specs}.

\subsection{Performance characteristics}

Depending on the details of how components are stored, this architecture maximizes the efficiency of the CPU cache when compared to the architectures of other simulators, which gives it a substantial performance advantage. This happens because the data for each component type can be stored in a single place, usually an array, and can be directly loaded into the cache when a system starts its execution, meaning that it has high cache spatial locality. As a result, the CPU does not need to check the RAM as often, which reduces the time it takes to retrieve data and consequently improves performance. For comparison, in simulators such as Vadere, the update loop first goes through each entity, and then it is able to load the data for each individual property. As a result, the CPU has to go through noncontinuous regions of memory, increasing the number of cache misses.

In addition, the fact that systems are independent allows for a certain level of parallelism to take advantage of multithreaded systems. This comes in two forms: internal and external parallelism. External parallelism is when two or more systems may be executed at the same time. This can happen when the systems do not modify any pieces of data that are used by each other, and there is no logical requirement for their execution to be sequential. Such an approach is useful when multiple kinds of data are necessary for one operation, but computing them is time-consuming. The expensive computations can be split off into multiple different systems that save their data to intermediate components. After all these computation systems have concluded their execution, the final system gathers the intermediate components and performs the operation. 

Internal parallelism can occur when it is possible to process each entry independently of each other. In this case, a system can split the data it has received into multiple groups that can be processed in parallel. These two modes of parallelism can also work together. In this situation, systems can be executed in parallel and systems can split their data into different parallel processes. \autoref{fig:external_vs_internal_parallelism} shows an example of these approaches.

\begin{figure}
  \centering
  \includesvg[inkscapelatex=false,width=\textwidth]{internal_vs_external_parallelism.drawio.svg}
  \caption[External and internal parallelism comparison]{Example of how internal and external parallelism work and how they operate when combined.}
  \label{fig:external_vs_internal_parallelism}
\end{figure}

While equivalent techniques could be employed on existing simulators, such changes would be challenging to archive and prone to causing issues. In \gls{ecs}, these changes are much simpler. Internal parallelism is possible in a large portion of cases, and it is much easier to implement, although it may not be worth it for simple and inexpensive systems. External parallelism is somewhat harder because it requires an analysis of the inputs of the systems to prevent concurrent modifications to the same piece of data or to handle it gracefully. However, some \gls{ecs} frameworks, such as Bevy ECS \cite{bevy}, allow for a seamless implementation of these concepts.

\subsection{Benefits and drawbacks}

In addition to the performance benefits, \gls{ecs} promotes adaptable and reusable design. Components work best when they represent a singular aspect of each entity and are elementary. Such components can be composed into multiple kinds of entities and, because the systems use the components associated with an entity to decide if they will perform operations on them, the behavior of the entities can be changed mid-simulation. For example, a pedestrian may have a \verb|Position| and \verb|Speed| component, which causes the \verb|SpeedSystem| to make it move according to its speed. If the pedestrian then decides to sit, the \verb|Speed| component can be removed, which automatically removes it from the \verb|SpeedSystem|'s list of entities to operate on. Also, if it is desired to add other kinds of moving objects to the simulation, cars for example, it is not necessary to create new logic to handle their movement. Any entity with \verb|Position| and \verb|Speed| will automatically be affected by the \verb|SpeedSystem|.

Despite these advantages, \gls{ecs} also poses some problems that have limited its acceptance even in the fields where it sees some use. The main one is lack of familiarity of programmers who use \gls{oop} and other common programming paradigms with the design principles it is built upon. For example, while \gls{ecs} can be implemented in \gls{oop}-focused languages, it breaks many of \gls{oop}'s principles. Making effective use of this architecture requires reframing problems to avoid some aspects, such as inheritance and polymorphism. This problem compounds on itself, as the lack of popularity means that, generally speaking, tooling for this architecture is less developed than others, and there is less information about it, which naturally perpetuates its status.

\gls{ecs} also has some problems inherent to its structure. Due to the fact that component data is effectively global, tracking down issues caused by improper manipulation of data is hard, as they could come from anywhere. Additionally, observing and understanding the global data is a complicated affair during debugging, as the data for each entity is spread around multiple places and possibly using multiple forms of storage, making it difficult to have a holistic picture of what the system's state is.


\section{ECSMoS implementation} \label{sec:ecsmos-implementation}

Considering the problem of other simulators referenced in \autoref{sec:existing-frameworks}, the main objective of \gls{ecsmos} is to be more flexible than existing simulators. It should accommodate the addition of new models easily, should remove as many constraints for model authors as possible, allow for the creation of variants of existing models and the creation of hybrid models. Additionally, it should be at least as performant as existing solutions. While there are other factors that greatly influence the usability of a simulator, such as UI, documentation, and integrations with other tools, these were not focused upon for this work. Any implementation for these or other areas was merely made for the purpose of supporting the goals of the project.

The main technological choice for the implementation of \gls{ecsmos} was the specific \gls{ecs} framework to be used. While there was the option of creating a bespoke implementation, it would likely be much less mature, stable, and feature-rich than the ones already available. Among the available options, Bevy ECS, an \gls{ecs} framework implemented in the Rust programming language, was chosen. This was due to how Rust and Bevy ECS complement each other, allowing for seamless external parallelism enabled by the compile-time guarantees provided by Rust's borrow-checker and explicit declaration of mutable values. These features allow Bevy to know at compile time which components and entities are accessed by any given system and whether they can perform changes to them. As such, a dependency graph can be constructed and Bevy can use that to prevent the execution of systems that conflict with each other (such as those that write to the same components) from being executed in parallel while allowing the non-conflicting ones to do so.

In addition to the standard \gls{ecs} constituents of entities, components, and systems, Bevy also provides a few more features. \textbf{Schedules} serve as management units for systems. They defined what systems are executed, what their execution order is, and under what conditions they are active. \textbf{System Sets} are system organizational units. They can be used to group systems that have similar functions or by any other differentiating factor. \textbf{Resources} are a way of storing data globally without association with a specific entity and are useful for representing global state. Bevy also has a built-in \textbf{Events} framework, which allows communication between systems without needing to update components. Finally, Bevy has an advanced change detection method, and developers are able to use that to only execute certain systems when certain components are added or changed, reducing computational load. These and many other features are all fully compatible with the Bevy's parallelization mechanisms, allowing full use of multithreaded hardware.

\subsection{ECSMoS Structure}

To improve organization and effectively provide a division of concerns, \gls{ecsmos} is built out of modules, which are built on top of what Bevy calls plugins. Each module can add its own systems, resources, components, etc., to the simulation. Modules are not executed in any particular order. Each of their systems can individually be configured to be executed before or after others. In cases where modules have a dependency on one another, meaning that a system in module A must be executed after a system in module B, system sets can be used to define this dependency behavior.

Bellow is a list of the currently available modules and their general function:

\begin{itemize}
  \item Default module: Enables basic internal Bevy modules useful for the general simulation framework
  \item Auto End Simulation module: Adds functionality for automatically stopping a simulation under certain conditions, such as when there are no more pedestrians or when a certain amount of time has passed
  \item Display module: Enables the \gls{ui} of the simulator
  \item Flow Field Pathfinding module: Used to compute the best paths for pedestrians at any given point to their destination. The data provided by this module is later used by the Social Forces module to compute the direction of the motivation force. This module is heavily inspired by the floor fields used on Vadere for the same purpose.
  \item Kinematics module: Handles basic movement according to the laws of physics. While other modules may handle the computation of forces, this module actually moves pedestrians according to their final speed.
  \item Movement Tracking module: Used for collecting and exporting data related to the movement of pedestrians in the simulation.
  \item Simple Objective module: Used for determining if a pedestrian has arrived at its destination (called an objective inside the simulation) and what actions should be taken next, most commonly removing it from the simulation.
  \item Simulation Area Module: Used for defining the region where the simulation takes place. Pedestrians that attempt to leave the simulation area are prevented from leaving. The information provided by this system is also useful for flow field pathfinding, which uses it to limit the paths it needs to compute.
  \item Social Forces Module: Implements the social forces model for simulating pedestrians.
  \item Spawner Module: Used for creating pedestrians at a defined region at a certain frequency, providing a constant flow of agents in the simulation.
  \item Start Time Module: Simply records the time at which the simulation started. This information is used during the export for naming and differentiating various simulation runs.
\end{itemize}

\autoref{fig:module_dependency} shows an example of how inter-module dependencies and system sets operate. It is important to note that it does not show all systems, and the general flow has been simplified for better understanding. The image shows two modules, their systems, system sets, and how they interact. The rounded boxes represent predefined system sets, and the arrows between the systems and system sets represent their dependencies. Systems without a dependency, such as \verb|Compute Obstacle Collision Map| can start execution as soon as possible and, in this example, can also be executed in parallel. Bevy executes systems in parallel in no particular order, and it can be changed from iteration to iteration. The height of each system denotes the period of time when it can be executed. As shown, \verb|Compute Motivation Force| depends on the Flow Field Pathfinding module's system set, meaning that it will only be executed after it has finished, unlike the other social forces systems.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{module_dependency.drawio.png}
  \caption[Example of how ECSMoS handles inter-module dependencies]{Example of how \gls{ecsmos} handles inter-module dependencies}
  \label{fig:module_dependency}
\end{figure}

In the event that it becomes necessary to create a new module that has systems that must be executed after the first three systems of the Flow Field Pathfinding module, but that does not need to wait for the remaining systems, the current system sets are not sufficient. In this situation, the new module could create a new system set that exists on top of the current structure. This set can then only include the desired systems and be used for defining dependencies. 
\autoref{fig:module_dependency_example_module} shows an example of this. This new set can be anonymous and, as such, remain in use only inside the module or be given an identifier that would allow it to be used by other modules. Either way, it has no impact on the pre-existing system set or any of its relationships.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{module_dependency_alt.drawio.png}
  \caption[Example of how ECSMoS handles the addition of systems with dependencies]{Example of how \gls{ecsmos} handles inter-module dependencies where there is no predefined system set grouping only the required systems. The thick dashed and rounded square represents the unnamed set created.}
  \label{fig:module_dependency_example_module}
\end{figure}

While generally a module is added as a whole. It is also possible to add only certain parts of it. For modules where there is a clear expectation that certain parts are only needed sometimes, it is possible to pass configuration variables to the module that enable or disable certain sections. If there was no expectation of this need during development, it is possible to bypass standard module initialization and add the required parts manually. While more time-consuming, this allows a large degree of control even over modules created by third parties. This is particularly useful when creating derivatives of pre-existing modules, as it allows the child module to only keep the parts of the parent that it desires while removing the others.

As a result of this approach, \gls{ecsmos} does not have a linear execution/relationship path between its modules like other simulators. Instead, it can be best imagined as a network, where each system is a node with its own relationships. Systems are generally more connected to other systems within the same module, but they often connect to other ones. While this increases the general flexibility of the simulator, it also comes with a drawback, as it allows for developers to unknowingly create circular dependency paths.

In its current state, \gls{ecsmos} has a simple \gls{ui} that is useful for debugging and visualizing the results during execution. The interface is built on top of Bevy's default rendering systems, which are relatively restrictive, but it is possible to add other \gls{ui} systems such as Bevy EGUI \cite{bevyegui}. This rendering functionality is not directly tied to the simulation state. There are systems that are executed at the end of each simulation loop that translate simulation data into values comprehensible by the \gls{ui} systems. As such, it is possible to add interface elements that are model-specific. 

Like Vadere, \gls{ecsmos} does not have a unified data collection or output mechanism. Both use data collectors, which only store certain fields, and post processors that output the collected data to one or multiple files. In both cases, a trajectory data collector is provided that is able to track the positions of pedestrians and export them in the \gls{csv} format or equivalent. However, more complex data collection may require additional systems to be created.

Finally, \gls{ecsmos} does not currently have a proper external file format for storing scenario definitions. Therefore, defining a scenario is currently done directly via code. Such a system is possible, but \gls{ecs} creates some additional complexities when it comes to this, most notably in the definition of system dependencies. While this is possible to do, it was not considered inside the scope of the current work.

\section{Evaluation} \label{sec:evaluation}

For the purposes of this work, two kinds of evaluations were defined for the simulator: qualitative and performance. The qualitative evaluation concerns itself with evaluating the usability, structure, reusability and other such aspects. In contrast, the performance evaluation consists of measuring its performance when compared to other simulators in similar test scenarios,  Of these two, the qualitative evaluation is arguably the most important. It focuses on comparing the capabilities of the simulators when it comes to the implementation of new models and adaptation of already existing ones. As such, it touches on the main objective of this project: flexibility. 

In addition to \gls{ecsmos}, two other simulators were selected for the comparison: Vadere and JuPedSim. These were chosen because they are the most robust ones still being updated. Out of the remaining simulators, MomenTUMv2 would also have been a suitable candidate due to how flexible its architecture is. However, the fact that its continued development is uncertain and that it was left in a non-functioning state with no clear indication of which previous version could be considered usable meant that it was decided to remove it from the comparison. Conversely, jCrowdSimulator receives regular updates but was not considered for this comparison for lacking much of the basic infrastructure of a general simulator and due to its tightly coupled nature.

\subsection{Qualitative Evaluation Strategy} \label{sec:qualitative-evaluation}

For qualitative evaluation, a set of common scenarios seen during the development of new models was formalized and proposed as test scenarios. \autoref{table:test-scenarios} contains a list of the scenarios. These were designed to test specific aspects of each simulator. However, they also had to be somewhat flexible to avoid hitting specific weak points of the simulators that could be easily avoided by slight shifts in the definition criteria. 

Scenario 1 contains an example of this flexibility. The simulators being evaluated do not all use the same basic pathfinding system. Since what pathfinding systems are available is not an object of study in this dissertation, it was decided to write the scenario in such a way as to allow for the use of any one of these. Similar accommodations have been made in the other scenarios. 

Scenarios 1 to 3 test basic situations that are likely to come up during the development of most novel models. If they are entirely novel, they would likely go with a path more similar to scenario 1. Models that are mostly based on another but have additional variables/factors would match scenario 2. Lastly, Scenario 3 covers additional implementations that may not cleanly fit into the previous categories.



Scenarios 4 and 6 take aim at features that are less commonly used but that may be hard barriers when it comes to implementation. Some models explicitly consider how an agent makes decisions in a changing environment \cite{DEIULIIS2023104527}, while others include actions that involve things other than movement, such as waiting in line and loitering \cite{KIM2013232, ALAM2022100527}. 

A simulator's pathfinding algorithm may also have limitations or performance issues. These algorithms are used to compute what path the pedestrians would attempt to take if the other agents around them were static and, for the \acrlong{sfm}, are used as a basis for the driving force. Vadere and \gls{ecsmos} use similar implementations that work well for the \gls{sfm} but that generally have worse performance for cellular automata models \cite{kleinmeierVadereOpenSourceSimulation2019}. As such, it may be necessary to change them under some set of circumstances. Scenario 5 tests that change.

After the scenario definitions, a study was made in implementing them on each simulator. Implementations were then graded according to three metrics: implementability (meaning ease of implementation), reusability, and complexity. These grades were given on a three-level scale, going from poor to good. The details of each level are described in \autoref{table:qualitative-evaluation-criteria}. In summary, a grade of "good" indicates that a simulator can easily handle the implementation of the scenario. Its architecture poses minimal challenges in regard to that criteria. Conversely, a grade of "poor" implies significant challenges, to the point that it may not be feasible to implement the scenario. Finally, a grade of "fair" indicates that there are some challenges, but these are possible to circumvent with a reasonable level of effort.

\begin{center}
  \begin{table}[h!]
    \begin{tabularx}{\textwidth}{ | p{2.9cm} | l | X | } 
      \hline
      Criteria & Grade & Description \\ 
      \hline
      Implementability & Good & 
      The simulator can easily accommodate the required additions. It has a clear place and method for receiving the new model, requiring minimal changes to existing code.
      \\ 
      \hline
      Implementability & Fair & 
      Implementation is feasible but requires moderate exploration of the code to identify where changes are needed or there are some tight coupling/rigid designs that slow down development.
      \\ 
      \hline
      Implementability & Poor & 
      Simulator lacks extension points for this scenario, requires deep internal changes or requires modification to parts of its code that would be very difficult to decouple. Implementation is slow, messy or may not be feasible.
      \\ 
      \hline
      Reusability & Good & 
      Existing code can easily be reused in this scenario. The related models, utility methods, etc. are  generic, have good abstractions, and are composed of easily swappable units.
      \\ 
      \hline
      Reusability & Fair & 
      Some reuse is possible, but components are partially coupled to specific behaviors or scenarios. Reusing core infrastructure may impose minor restrictions or require small modifications. Model-specific logic may need to duplicate existing features if interfaces are too narrow or rigid.
      \\ 
      \hline
      Reusability & Poor & 
      Simulator components are hard-coded or specialized for specific agents or scenarios. Implementing the scenario requires rewriting or duplicating most, if not all, of a model or internal system to operate. 
      \\ 
      \hline
      Complexity & Good & 
      Implementing the scenario is possible with minimal cognitive effort. The changes are well isolated, have logical continuity, touch as few other systems and the data/execution path they follow is direct and predictable.
      \\ 
      \hline
      Complexity & Fair & 
      Implementing the scenario requires working with several components whose relationships aren't always intuitive. Changes may need to be performed in many regions of the code. Understanding the control flow is unintuitive or time-consuming, but possible.
      \\ 
      \hline
      Complexity & Poor & 
      Fully integrating the scenario is very complicated. Control flow is chaotic, multiple tightly coupled parts have to be modified, or they may require a large redesign of the architecture of the simulator itself.
      \\ 
      \hline
    \end{tabularx}
    \caption{Description of evaluation criteria and their levels.}
    \label{table:qualitative-evaluation-criteria}
  \end{table}
\end{center}

\begin{center}
  \begin{table}[h!]
    \begin{tabularx}{\textwidth}{ | l | p{3.7cm}| X | p{5cm} | } 
      \hline
      \textnumero & Name & Description & Objective \\ 
      \hline
      1 & 
      New Model &  
      Add a new simple model that uses a basic pathfinding system already implemented on the simulator& 
      Test reusability of basic simulator infrastructure\\
      \hline
      2 & 
      Model variation &  
      Create a variation of the Social Forces Model available in the simulator with an additional attractive force that guides agents to areas where pedestrians would naturally concentrate, as defined in \cite{helbingSocialForceModel1995}& 
      Test reusability of existing model implementations when the variation is small\\
      \hline
      3 & 
      Hybrid model &  
      Create a model based on an already existing one that changes how it operates under some set of circumstances, similar to models that take panic into account, like those in \cite{Alrashed_Shamma_2020} & 
      Test general adaptability of already existing models to larger changes\\
      \hline
      4 & 
      Procedural environment changes &  
      Create a simulation environment that changes over time, adding new obstacles that change the pedestrian's paths as seen on \cite{DEIULIIS2023104527} & 
      Determine whether the simulator is able to handle updates to data that is not related to the pedestrians directly\\
      \hline
      5 & 
      Implementing a new pathfinding algorithm &  
      Add a new algorithm for determining the shortest route between a pedestrian's current location and their destination& 
      Check the flexibility of current models to changes in base infrastructure, which may be necessary for performance or other limitations \cite{kleinmeierVadereOpenSourceSimulation2019}\\
      \hline
      6 & 
      Queuing and loitering&  
      Add procedures for pedestrians forming queues and for pedestrians staying still while waiting for something, but with some level of reactivity to the surrounding environment& 
      Queuing and loitering are behaviors that significantly change how a pedestrian moves and interacts with its environment. They also break many assumptions that are usually made by models, which often require continuous movement \cite{KIM2013232}\\
      \hline
    \end{tabularx}
    \caption{List and description of test scenarios.}
    \label{table:test-scenarios}
  \end{table}
\end{center}






\subsection{Performance Evaluation Strategy} \label{sec:performace-evaluation}

When it comes to scientific pedestrian simulation software, performance is often a secondary concern. For many such applications, the total amount of time it takes for the simulator to run is of little concern as long as it does not impede or unreasonably slow down the research process. Considering these factors, the main objective of this evaluation is to measure the general effect of the change in architecture to the performance of the simulated models, not to perform a comprehensive comparison. 

As there are no standard scenarios used for performance comparison, it was necessary to develop new ones. Following the described objective of this evaluation, minimizing the effects of other factors was paramount. Firstly, complicated topologies disadvantage simulators like JuPedSim, which determine base routes via a method that requires polygon triangulation. The more polygons there are in a situation, the slower it is to compute the base paths of pedestrians. On the other hand, large spaces, even if empty, substantially increase the number of computations that simulators like Vadere and ECSMoS require. These factors are independent of architecture and cause non-linear performance drops that can change both depending on the topology and the number of pedestrians in the simulation. As a result, it was decided to create scenarios that minimize these effects.

This evaluation focuses on how each simulator handles an increasing number of pedestrians in a few scenarios. The simulations start with zero agents on the field, and increasing amounts are added. Once each agent arrives at its objective, it is removed from the simulation. Other than topology, the main factor that varies from simulation scenarios is the frequency with which pedestrians are added, designated $f_p$, measured in $pedestrians/s$, and varying from $0.5$ to $8$. The low values of $f_p$ mimic areas with low but active pedestrian traffic, the intermediary ones slowly go towards saturation, and, at high values, the equivalent of traffic jams for pedestrians starts to happen.

The Social Forces Model was used for all experiments and the simulator constants were standardized to those seen on \autoref{table:sfm-constantns} or equivalent values in each simulator. These include the calibration constants see on \autoref{eq:pedestrian_repulsion}, \autoref{eq:pedestrian_obstacle} and \autoref{eq:pedestrian_final_speed}. As there is no clear equivalence between the underlying algorithms for computing the shortest path between a pedestrian and its destination, a piece of data crucial for the computation of the motivation force, these have been left at their default values.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{ | l | c | c | } 
      \hline
      Parameter & Value & Unit\\ 
      \hline 
      $A_i$ & 2000 & $N$\\
      \hline
      $B_i$ & 0.08 & $m$\\
      \hline
      $k$ & 120000 & $\frac{kg}{s^2}$\\
      \hline
      $\kappa$ & 240000 & $\frac{kg}{m \cdot s}$\\
      \hline
      $r_i$ & 0.3 & $m$\\
      \hline
      $\tau$ & 0.5 & $s$\\
      \hline
      $v_i^0$ & 0.8 & $\frac{m}{s}$\\
      \hline
      $m$ & 80 & $kg$\\
      \hline
      $\Delta T$ & 0.1 & $s$\\
      \hline 
    \end{tabular}
    \caption{Performance evaluation simulation constants}
    \label{table:sfm-constantns}
  \end{center}
\end{table}

Two scenarios were developed for this evaluation. \autoref{fig:performace_scenario_topologies} displays their physical topology. On these figures, black regions represent walls, green represents pedestrian spawners, meaning locations where pedestrians are added with a certain frequency, and red represents destinations, meaning that pedestrians are trying to go there, and they get removed from the simulation once they have arrived. Spawners and destinations are marked with a letter to represent their pairing. So pedestrians from spawner A will attempt to get to destination A.

\begin{figure}[h]
  \centering
  \begin{subfigure}{.33\textwidth}
    \centering
    \includesvg[width=.9\linewidth]{performance_scenario_1.svg}
    \caption{Scenario 1 -  Bottleneck}
    \label{fig:sfig1}
  \end{subfigure}%
  \begin{subfigure}{.67\textwidth}
    \centering
    \includesvg[width=.88\linewidth]{performance_scenario_2.svg}
    \caption{Scenario 2 - Corridor}
    \label{fig:sfig1}
  \end{subfigure}%
  \caption{Performance scenario topologies}
  \label{fig:performace_scenario_topologies}
\end{figure}

Both of the developed scenarios have a simple topology and small surface area. However, they were created with a basis on actual topologies used during the development of novel pedestrian models. Similar topologies to the ones seen in Scenario 1 are oftentimes used to test whether models display the "Faster-Is-Slower Effect", where an increase in pedestrian speed may actually reduce total throughput when there is a bottleneck on the path. Scenario 2 focuses on lane formation, a situation where pedestrians create lanes of traffic when there are many pedestrians moving in different directions.

Each scenario was measured in terms of how long it takes to simulate the equivalent of 5 minutes in simulation time under various circumstances. This amount of time was chosen because it is enough for the low and medium $f_p$ values to reach equilibrium (when the number of pedestrians entering the simulation and leaving is the same), but not enough for the higher values to completely fill the whole simulation area with pedestrians at the higher values. Each scenario was executed 10 times and an average was taken as the result.

\subsection{Qualitative Evaluation Results}

Following the directives defined in \autoref{sec:qualitative-evaluation}, each scenario was implemented sequentially. In cases where there were examples, extension points or documentation pointing towards a recommended implementation path from the developers, these were followed. When there was no explicit guidance, various approaches were attempted to arrive at the best possible one according to the evaluation criteria defined. Below is a description of the results with some additional commentary. A summary of the same can be seen in \autoref{table:qualitative-summary}.

Each simulator had very similar results in scenarios 1, 2, and 3. These are not complicated setups and serve as a comparison basis for the other ones. However, they already reveal some trends that will persist over most of the other scenarios. Firstly, even in basic scenarios, \gls{ecsmos} is more complicated than desired. This is due to how open-ended its architecture is. Because new systems can be added to any particular point in the schedule, in practice it means that it is always somewhat complicated to understand the control flow of the simulator. However, implementing model variations and hybrid models works well, as these can be added on top of existing models easily via the addition of a few systems that work together with the older ones.

Secondly, JuPedSim generally performs worse than the others being studied under these criteria. Such a pattern stems from its highly coupled internal structure. Even in basic scenarios, JuPedSim requires many changes all around the codebase in the form of string comparisons and others that define how execution will go depending on each model. This is most notable in the interface between Python and C++ code, where there are large sections of model-specific code that are executed depending on a sequence of chained conditions.

Finally, Vadere receives a downgrade in reusability scores starting on scenario 2 due to the fact that its pre-existing model implementations have a somewhat limited level of extensibility. With better choices when it comes to how the code is divided or how classes and interfaces are structured, it could cut down on the amount of code duplication significantly.

Scenario 4 introduces more challenges when it comes to flexibility. Both Vadere and JuPedSim suffer on this front, as they assume static environments, which is a reasonable expectation for some simpler situations, but that is not a universal property. Within Vadere, it is still possible to accommodate these with some work, but it will require reengineering some portions of the simulator itself. However, they are basically unimplementable in JuPedSim, as it would require reengineering most of the simulator. In comparison, \gls{ecsmos} handles such things much better. Bevy ECS provides methods for detecting this kind of changes and, in many situations, these can be added with little to no modification to the code of the systems themselves. In the situation where changes to the systems are necessary, those are limited and much more predictable. 

\begin{center}
  \begin{table}[h!]
    \begin{tabularx}{\textwidth}{ | p{3.7cm} | X | X | X | X | X | X | X | X | X | } 
      \hline
      \backslashbox{Scenario}{Simulator} & 
      \multicolumn{3}{|c|}{\gls{ecsmos}} & 
      \multicolumn{3}{|c|}{Vadere} & 
      \multicolumn{3}{|c|}{JuPedSim} 
      \\
      \hline
      &
      \rotatebox[origin=c]{90}{\hphantom{O}Implementability\hphantom{O}} &
      \rotatebox[origin=c]{90}{Reusability} &
      \rotatebox[origin=c]{90}{Complexity} &

      \rotatebox[origin=c]{90}{Implementability} &
      \rotatebox[origin=c]{90}{Reusability} &
      \rotatebox[origin=c]{90}{Complexity} &

      \rotatebox[origin=c]{90}{Implementability} &
      \rotatebox[origin=c]{90}{Reusability} &
      \rotatebox[origin=c]{90}{Complexity} 
      \\ 
      \hline
      (1) New Model & 
      Good & Good & Fair & 
      Good & Good & Good & 
      Fair & Fair & Fair\\
      \hline
      (2) Model variation & 
      Good & Good & Fair & 
      Good & Fair & Good & 
      Fair & Fair & Fair\\
      \hline
      (3) Hybrid model & 
      Good & Good & Fair & 
      Good & Fair & Good & 
      Fair & Fair & Fair \\
      \hline
      (4) Procedural environment changes &
      Good & Good & Fair &
      Fair & Fair & Poor &
      Poor & Poor & Poor \\
      \hline
      (5) Implementing new pathfinding algorithm &
      Good & Fair & Fair &
      Poor & Fair & Poor &
      Fair & Fair & Fair \\
      \hline
      (6) Queuing and loitering&
      Good & Good & Fair &
      Good & Poor & Good &
      Good & Good & Good \\
      \hline
    \end{tabularx}
    \caption{Summary of qualitative results.}
    \label{table:qualitative-summary}
  \end{table}
\end{center}

Scenario 5 causes a reversal in the grades between Vadere and JuPedSim. Vadere's pathfinding algorithm, referred to as floor fields, is much more integrated with the simulator architecture and existing models than JuPedSim's, which uses triangulation to determine the best possible path for each pedestrian. While it is possible to replace floor fields with some other mechanism, it would involve changing much of the simulator code and all current implementations of models, making it impractical. In \gls{ecsmos}, such a thing is perfectly possible. Reuse of code between the current pathfinding system and a new one may be limited, but the architecture will not impose additional challenges, and the changes necessary to allow already existing models to use it are small and concentrated in singular places.

Finally, in scenario 6, JuPedSim performs very well. Its architecture actively expects such behavior, so it is well integrated and quite flexible to changes. While \gls{ecsmos} was not designed with this in mind, this can be accomplished similarly to how hybrid models were implemented in scenario 3. Queuing and loitering work as an extension on top of the already available model. Vadere's implementation in theory could be done in the same way as \gls{ecsmos}'s, but in practice it would require rewriting the whole model to take this into account due to some limits to its extensibility. Therefore, it gets a downgrade in the reusability criteria.

As the results in  \autoref{table:qualitative-summary} show, Vadere and \gls{ecsmos} are the best for basic scenarios, with Vadere having a slight edge. Each one has its strong and weak points, but they are generally good choices for implementing a novel pedestrian model that does not take into account more complicated things such as changes to the environment. However, once more involved changes are necessary, \gls{ecsmos} pulls ahead because of its flexibility. In contrast, JuPedSim has generally worse results than these two, with its only standout result on scenario 6.


\subsection{Performance Evaluation Results}

Similarly to the qualitative results, the performance results were very similar for the less demanding cases, while diverging significantly on later ones. \autoref{fig:performace-results} shows us the full results in detail. In that figure, scenarios are identifiable by the shape of the markers used on the graph, while each simulator got its own color. The shaded areas around each trend line are the standard deviation of each measurement, which measures the variability of each result.

As it is possible to see, the results for lower values of $f_p$ are very similar across simulators and scenarios. With such low amounts of pedestrians, the base costs of loading data into memory, pre-processing, post-processing and other fixed costs dominate. There is still some variation, most notably from Vadere, which is written in Java and therefore has a slower general performance than the other ones because Java is not fully compiled. Instead it is partially compiled into an intermediary language that then needs to be interpreted. JuPedSim uses Python, a fully interpreted language, but most of its core is written in C++ and the Python wrapper simply serves to give a convenient interface to the user, as it passes execution to the C++ layer immediately.

Starting at $f_p = 3$, no data is available for JuPedSim on scenario 2. At $f_p = 6$, the same becomes true for scenario 1. This is due to a limitation in JuPedSim. As pedestrian densities increase inside the simulation, it is possible in rare circumstances for the repulsive interaction between pedestrians to be so strong that a pedestrian may be going so fast that its position in the next simulation loop goes over the barriers that limit the simulation area, so it appears on the outside. Said behavior is a common error for both simulators and games and stems from a simplification of the collision detection code. Instead of checking if the pedestrians would have to go through a wall to arrive at a certain position, the code simply checks if there is a wall at the location the agent is going to. At low speeds this approach is sufficient, but it has limited applicability at higher speeds.

Such high speeds are not usually possible for pedestrians in the real world, but similar situations can arise in many models, including the Social Forces Model. A common location for this to happen is around the regions where pedestrians are added. In these locations, a new pedestrian may be added much closer to others than it would be normally possible, creating large forces. Both Vadere and \gls{ecsmos} handle it by using a configurable maximum speed that is well below the threshold where it could cause problems. Since such speeds are physically impossible in real-world scenarios, a maximum speed helps the model behave in a more realistic way. However, JuPedSim does not have that check nor does it provide a way to configure it. As a result, even modest densities can overwhelm it in certain situations. It does not happen on all runs, but they become common enough at $f_p = 3$ and $f_p = 6$ that it becomes infeasible to gather representative results.

Vadere and \gls{ecsmos} exhibit an overall quadratic growth in simulation duration as the frequency increases. Although there are many ways to optimize it, the Social Forces Model naturally leads to that kind of growth. Each pedestrian both applies forces to others and receives a reciprocal force from them. These need to be computed for each individual pair of agents, which grows with the square of the number of agents in a simulation. However, at higher frequencies, there is a large difference in performance between the two, but it is difficult to quantify how much of this comes from the change in architecture and how much comes from the difference in language. 

The comparing \gls{ecsmos} to JuPedSim is simpler in that aspect, as C++ and Rust have very similar performance profiles \cite{electronics12010143}. In the proposed scenarios, both simulators have near identical performance for the lower frequencies. This could indicate some degree of equivalence between their architectures in terms of performance, but the lack of data for the later runs for JuPedSim means that it is not possible to make reliable assertions on this matter.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{performace_result.png}
  \caption[Summary of performance results]{Summary of performance results}
  \label{fig:performace-results}
\end{figure}

\section{Conclusion} \label{sec:conclusion}

This research aimed to determine the benefits and drawbacks of introducing the \gls{ecs} architecture into the realm of scientific pedestrian simulations with a focus on flexibility. As part of this, the area of pedestrian simulations was studied, including currently available pedestrian models and a survey of pedestrian simulators. With this context established, the characteristics of the \gls{ecs} architecture were laid out in comparison to the ones used by current simulators. Finally, a novel simulation framework, \gls{ecsmos}, was proposed, developed and compared against some of the most popular pedestrian simulators, Vadere and JuPedSim.

The results of the qualitative analysis show that \gls{ecsmos} is more flexible when compared to the other subjects of study overall, with special highlights in situations that require procedural environment changes, where both of the other simulators face significant challenges. However, this comes at the expense of complexity. \gls{ecsmos} is generally more complex than the alternatives in simpler scenarios. This drawback only ever disappears when finer control or flexibility is required. In terms of performance, \gls{ecsmos} is just as or more performant than the alternatives in all studied scenarios. Still, these results are not fully comparable, as there are other significant factors that may affect performance that cannot be isolated.

Based on these results, it is possible to conclude that \gls{ecs} is a viable alternative to currently accepted programming paradigms used in the simulation of pedestrians. Its benefits come in the form of flexibility and control, but they come with drawbacks in terms of required learning for unfamiliar researchers and a generally complex execution flow and debugging procedures. Therefore, it is best used for implementing models that require features that are not currently standard or break the general assumptions when it comes to pedestrian model structure.

Future works in this area should focus on expanding the current simulation core with features necessary for a fully fledged simulator. These may include a better UI, mechanisms for defining scenarios via external files, better data gathering, supporting other export formats, and many others. Additionally, it may be possible to use some of the strategies and concepts of \gls{ecs} on other simulators. This path of research may allow researchers to have the benefits of \gls{ecs} without needing to learn a  novel architecture or reimplement existing tools.

\printbibliography

\end{document}